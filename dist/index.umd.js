!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t="undefined"!=typeof globalThis?globalThis:t||self).CanvasParticles=i()}(this,function(){"use strict";const t=2*Math.PI;const i=function(t){let i=t>>>0;return{next(){let t=i+1831565813|0;return i=t,t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296}}}(Math.random()*2**32).next;class s{static version="4.1.4";static interactionType=Object.freeze({NONE:0,SHIFT:1,MOVE:2});static canvasIntersectionObserver=new IntersectionObserver(t=>{for(const i of t){const t=i.target,s=t.instance;if(!s.options?.animation)return;(t.inViewbox=i.isIntersecting)?s.options.animation?.startOnEnter&&s.start({auto:!0}):s.options.animation?.stopOnLeave&&s.stop({auto:!0,clear:!1})}});static canvasResizeObserver=new ResizeObserver(t=>{for(const i of t){i.target.instance.updateCanvasRect()}for(const i of t){i.target.instance.resizeCanvas()}});canvas;ctx;lastAnimationFrame=0;enableAnimating=!1;isAnimating=!1;particles=[];particleCount=0;clientX=1/0;clientY=1/0;mouseX=1/0;mouseY=1/0;width;height;offX;offY;option;color;constructor(t,i={}){let e;if(t instanceof HTMLCanvasElement)e=t;else{if("string"!=typeof t)throw new TypeError("selector is not a string and neither a HTMLCanvasElement itself");if(e=document.querySelector(t),!(e instanceof HTMLCanvasElement))throw new Error("selector does not point to a canvas")}this.canvas=e,this.canvas.instance=this,this.canvas.inViewbox=!0;const n=this.canvas.getContext("2d");if(!n)throw new Error("failed to get 2D context from canvas");this.ctx=n,this.options=i,s.canvasIntersectionObserver.observe(this.canvas),s.canvasResizeObserver.observe(this.canvas),this.resizeCanvas=this.resizeCanvas.bind(this),this.handleMouseMove=this.handleMouseMove.bind(this),this.handleScroll=this.handleScroll.bind(this),this.updateCanvasRect(),this.resizeCanvas(),window.addEventListener("mousemove",this.handleMouseMove,{passive:!0}),window.addEventListener("scroll",this.handleScroll,{passive:!0})}updateCanvasRect(){const{top:t,left:i,width:s,height:e}=this.canvas.getBoundingClientRect();this.canvas.rect={top:t,left:i,width:s,height:e}}handleMouseMove(t){this.enableAnimating&&(this.clientX=t.clientX,this.clientY=t.clientY,this.isAnimating&&this.updateMousePos())}handleScroll(){this.enableAnimating&&(this.updateCanvasRect(),this.isAnimating&&this.updateMousePos())}updateMousePos(){const{top:t,left:i}=this.canvas.rect;this.mouseX=this.clientX-i,this.mouseY=this.clientY-t}resizeCanvas(){const t=this.canvas.width=this.canvas.rect.width,i=this.canvas.height=this.canvas.rect.height;this.mouseX=1/0,this.mouseY=1/0,this.width=Math.max(t+2*this.option.particles.connectDist,1),this.height=Math.max(i+2*this.option.particles.connectDist,1),this.offX=(t-this.width)/2,this.offY=(i-this.height)/2,this.option.particles.regenerateOnResize||0===this.particles.length?this.newParticles():this.matchParticleCount({updateBounds:!0}),this.isAnimating&&this.#t()}#i(){const t=this.option.particles.ppm*this.width*this.height/1e6|0;if(this.particleCount=Math.min(this.option.particles.max,t),!isFinite(this.particleCount))throw new RangeError("number of particles must be finite. (options.particles.ppm)")}newParticles(){this.#i(),this.particles=[];for(let t=0;t<this.particleCount;t++)this.createParticle()}matchParticleCount({updateBounds:t=!1}={}){for(this.#i(),this.particles=this.particles.slice(0,this.particleCount),t&&this.particles.forEach(t=>this.#s(t));this.particleCount>this.particles.length;)this.createParticle()}createParticle(s,e,n,o,a){const r={posX:s="number"==typeof s?s-this.offX:i()*this.width,posY:e="number"==typeof e?e-this.offY:i()*this.height,x:s,y:e,velX:0,velY:0,offX:0,offY:0,dir:n||i()*t,speed:o||(.5+.5*i())*this.option.particles.relSpeed,size:a||(.5+i()**5*2)*this.option.particles.relSize,gridPos:{x:1,y:1},isVisible:!1};this.#s(r),this.particles.push(r)}#s(t){t.bounds={top:-t.size,right:this.canvas.width+t.size,bottom:this.canvas.height+t.size,left:-t.size}}#e(){const t=0!==this.option.gravity.repulsive,i=0!==this.option.gravity.pulling;if(!t&&!i)return;const s=this.particleCount,e=this.option.particles.connectDist*this.option.gravity.repulsive,n=this.option.particles.connectDist*this.option.gravity.pulling,o=this.option.particles.connectDist/2,a=.1*this.option.particles.connectDist;for(let t=0;t<s;t++)for(let r=t+1;r<s;r++){const s=this.particles[t],h=this.particles[r],c=s.posX-h.posX,l=s.posY-h.posY,p=Math.sqrt(c*c+l*l);let u,d=1;if(p<o){u=Math.atan2(h.posY-s.posY,h.posX-s.posX),d=(1/p)**1.8;const t=Math.min(a,d*e),i=Math.cos(u)*t,n=Math.sin(u)*t;s.velX-=i,s.velY-=n,h.velX+=i,h.velY+=n}if(!i)continue;void 0===u&&(u=Math.atan2(h.posY-s.posY,h.posX-s.posX),d=(1/p)**1.8);const f=Math.min(a,d*n),v=Math.cos(u)*f,m=Math.sin(u)*f;s.velX+=v,s.velY+=m,h.velX-=v,h.velY-=m}}#n(){for(let e of this.particles){e.dir=(e.dir+i()*this.option.particles.rotationSpeed*2-this.option.particles.rotationSpeed)%t,e.velX*=this.option.gravity.friction,e.velY*=this.option.gravity.friction,e.posX=(e.posX+e.velX+Math.sin(e.dir)*e.speed%this.width+this.width)%this.width,e.posY=(e.posY+e.velY+Math.cos(e.dir)*e.speed%this.height+this.height)%this.height;const n=e.posX+this.offX-this.mouseX,o=e.posY+this.offY-this.mouseY;if(this.option.mouse.interactionType!==s.interactionType.NONE){const t=this.option.mouse.connectDist/Math.hypot(n,o);this.option.mouse.distRatio<t?(e.offX+=(t*n-n-e.offX)/4,e.offY+=(t*o-o-e.offY)/4):(e.offX-=e.offX/4,e.offY-=e.offY/4)}e.x=e.posX+e.offX,e.y=e.posY+e.offY,this.option.mouse.interactionType===s.interactionType.MOVE&&(e.posX=e.x,e.posY=e.y),e.x+=this.offX,e.y+=this.offY,e.gridPos=this.#o(e),e.isVisible=1===e.gridPos.x&&1===e.gridPos.y}}#o(t){return{x:+(t.x>=t.bounds.left)+ +(t.x>t.bounds.right),y:+(t.y>=t.bounds.top)+ +(t.y>t.bounds.bottom)}}#a(t,i){return!(!t.isVisible&&!i.isVisible)||!(t.gridPos.x===i.gridPos.x&&1!==t.gridPos.x||t.gridPos.y===i.gridPos.y&&1!==t.gridPos.y)}#r(){for(let i of this.particles)i.isVisible&&(i.size>1?(this.ctx.beginPath(),this.ctx.arc(i.x,i.y,i.size,0,t),this.ctx.fill(),this.ctx.closePath()):this.ctx.fillRect(i.x-i.size,i.y-i.size,2*i.size,2*i.size))}#h(){const t=this.particleCount,i=this.option.particles.connectDist,s=i>=Math.min(this.canvas.width,this.canvas.height),e=i*this.option.particles.maxWork,n=this.color.alpha,o=this.color.alpha*i;for(let a=0;a<t;a++){let r=0;for(let h=a+1;h<t;h++){const t=this.particles[a],c=this.particles[h];if(!s&&!this.#a(t,c))continue;const l=t.x-c.x,p=t.y-c.y,u=Math.sqrt(l*l+p*p);if(!(u>i)&&(this.ctx.globalAlpha=u>i/2?o/u-n:n,this.ctx.beginPath(),this.ctx.moveTo(t.x,t.y),this.ctx.lineTo(c.x,c.y),this.ctx.stroke(),(r+=u)>=e))break}}}#t(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.globalAlpha=this.color.alpha,this.ctx.fillStyle=this.color.hex,this.ctx.strokeStyle=this.color.hex,this.ctx.lineWidth=1,this.#r(),this.#h()}#c(){this.isAnimating&&(requestAnimationFrame(()=>this.#c()),this.#e(),this.#n(),this.#t())}start({auto:t=!1}={}){return this.isAnimating||t&&!this.enableAnimating||(this.enableAnimating=!0,this.isAnimating=!0,this.updateCanvasRect(),requestAnimationFrame(()=>this.#c())),!this.canvas.inViewbox&&this.option.animation.startOnEnter&&(this.isAnimating=!1),this}stop({auto:t=!1,clear:i=!0}={}){return t||(this.enableAnimating=!1),this.isAnimating=!1,!1!==i&&this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),!0}destroy(){this.stop(),s.canvasIntersectionObserver.unobserve(this.canvas),s.canvasResizeObserver.unobserve(this.canvas),window.removeEventListener("mousemove",this.handleMouseMove),window.removeEventListener("scroll",this.handleScroll),this.canvas?.remove(),Object.keys(this).forEach(t=>delete this[t])}set options(t){const i=(t,i,s)=>{const{min:e=-1/0,max:n=1/0}=s??{};return((t,i)=>isNaN(+t)?i:+t)(Math.min(Math.max(t??i,e),n),i)};this.option={background:t.background??!1,animation:{startOnEnter:!!(t.animation?.startOnEnter??1),stopOnLeave:!!(t.animation?.stopOnLeave??1)},mouse:{interactionType:i(t.mouse?.interactionType,1),connectDistMult:i(t.mouse?.connectDistMult,2/3),connectDist:1,distRatio:i(t.mouse?.distRatio,2/3)},particles:{regenerateOnResize:!!t.particles?.regenerateOnResize,color:t.particles?.color??"black",ppm:i(t.particles?.ppm,100),max:i(t.particles?.max,500),maxWork:i(t.particles?.maxWork,1/0,{min:0}),connectDist:i(t.particles?.connectDistance,150,{min:1}),relSpeed:i(t.particles?.relSpeed,1,{min:0}),relSize:i(t.particles?.relSize,1,{min:1}),rotationSpeed:i(t.particles?.rotationSpeed,2,{min:0})/100},gravity:{repulsive:i(t.gravity?.repulsive,0),pulling:i(t.gravity?.pulling,0),friction:i(t.gravity?.friction,.8,{min:0,max:1})}},this.setBackground(this.option.background),this.setMouseConnectDistMult(this.option.mouse.connectDistMult),this.setParticleColor(this.option.particles.color)}get options(){return this.option}setBackground(t){if(t){if("string"!=typeof t)throw new TypeError("background is not a string");this.canvas.style.background=this.option.background=t}}setMouseConnectDistMult(t){this.option.mouse.connectDist=this.option.particles.connectDist*(isNaN(t)?2/3:t)}setParticleColor(t){if(this.ctx.fillStyle=t,"#"===String(this.ctx.fillStyle)[0])this.color={hex:String(this.ctx.fillStyle),alpha:1};else{let t=String(this.ctx.fillStyle).split(",").at(-1);t=t?.slice(1,-1)??"1",this.ctx.fillStyle=String(this.ctx.fillStyle).split(",").slice(0,-1).join(",")+", 1)",this.color={hex:String(this.ctx.fillStyle),alpha:isNaN(+t)?1:+t}}}}return s});
