!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t="undefined"!=typeof globalThis?globalThis:t||self).CanvasParticles=i()}(this,function(){"use strict";class t{static version="4.1.0";static interactionType=Object.freeze({NONE:0,SHIFT:1,MOVE:2});static canvasIntersectionObserver=new IntersectionObserver(t=>{for(const i of t){const t=i.target,s=t.instance;if(!s.options?.animation)return;(t.inViewbox=i.isIntersecting)?s.options.animation?.startOnEnter&&s.start({auto:!0}):s.options.animation?.stopOnLeave&&s.stop({auto:!0,clear:!1})}});static canvasResizeObserver=new ResizeObserver(t=>{for(const i of t){i.target.instance.updateCanvasRect()}for(const i of t){i.target.instance.resizeCanvas()}});canvas;ctx;enableAnimating=!1;isAnimating=!1;particles=[];clientX=1/0;clientY=1/0;mouseX=1/0;mouseY=1/0;width;height;offX;offY;updateCount;particleCount;option;color={hex:"000000",alpha:0};constructor(i,s={}){let e;if(i instanceof HTMLCanvasElement)e=i;else{if("string"!=typeof i)throw new TypeError("selector is not a string and neither a HTMLCanvasElement itself");if(e=document.querySelector(i),!(e instanceof HTMLCanvasElement))throw new Error("selector does not point to a canvas")}this.canvas=e,this.canvas.instance=this,this.canvas.inViewbox=!0;const o=this.canvas.getContext("2d");if(!o)throw new Error("failed to get 2D context from canvas");this.ctx=o,this.options=s,t.canvasIntersectionObserver.observe(this.canvas),t.canvasResizeObserver.observe(this.canvas),this.resizeCanvas=this.resizeCanvas.bind(this),this.handleMouseMove=this.handleMouseMove.bind(this),this.handleScroll=this.handleScroll.bind(this),this.updateCanvasRect(),this.resizeCanvas(),window.addEventListener("mousemove",this.handleMouseMove),window.addEventListener("scroll",this.handleScroll)}handleMouseMove(t){this.enableAnimating&&(this.clientX=t.clientX,this.clientY=t.clientY,this.updateMousePos())}handleScroll(){this.enableAnimating&&(this.updateCanvasRect(),this.updateMousePos())}updateMousePos(){const{top:t,left:i}=this.canvas.rect;this.mouseX=this.clientX-i,this.mouseY=this.clientY-t}resizeCanvas(){const t=this.canvas.width=this.canvas.rect.width,i=this.canvas.height=this.canvas.rect.height;this.mouseX=1/0,this.mouseY=1/0,this.updateCount=1/0,this.width=Math.max(t+2*this.option.particles.connectDist,1),this.height=Math.max(i+2*this.option.particles.connectDist,1),this.offX=(t-this.width)/2,this.offY=(i-this.height)/2,this.option.particles.regenerateOnResize||0===this.particles.length?this.newParticles():this.matchParticleCount({updateBounds:!0}),this.isAnimating&&this.#t()}updateCanvasRect(){const{top:t,left:i,width:s,height:e}=this.canvas.getBoundingClientRect();this.canvas.rect={top:t,left:i,width:s,height:e}}#i(){const t=this.option.particles.ppm*this.width*this.height/1e6|0;if(this.particleCount=Math.min(this.option.particles.max,t),!isFinite(this.particleCount))throw new RangeError("number of particles must be finite. (options.particles.ppm)")}newParticles(){this.#i(),this.particles=[];for(let t=0;t<this.particleCount;t++)this.createParticle()}matchParticleCount({updateBounds:t=!1}={}){for(this.#i(),this.particles=this.particles.slice(0,this.particleCount),t&&this.particles.forEach(t=>this.#s(t));this.particleCount>this.particles.length;)this.createParticle()}createParticle(t,i,s,e,o){const n={posX:t="number"==typeof t?t-this.offX:Math.random()*this.width,posY:i="number"==typeof i?i-this.offY:Math.random()*this.height,x:t,y:i,velX:0,velY:0,offX:0,offY:0,dir:s||2*Math.random()*Math.PI,speed:e||(.5+.5*Math.random())*this.option.particles.relSpeed,size:o||(.5+Math.random()**5*2)*this.option.particles.relSize,gridPos:{x:1,y:1},isVisible:!1};this.#s(n),this.particles.push(n)}#s(t){t.bounds={top:-t.size,right:this.canvas.width+t.size,bottom:this.canvas.height+t.size,left:-t.size}}#e(){const t=0!==this.option.gravity.repulsive,i=0!==this.option.gravity.pulling;if(t||i){const t=this.particleCount,s=this.option.particles.connectDist*this.option.gravity.repulsive,e=this.option.particles.connectDist*this.option.gravity.pulling,o=this.option.particles.connectDist/2,n=.1*this.option.particles.connectDist;for(let a=0;a<t;a++)for(let r=a+1;r<t;r++){const t=this.particles[a],h=this.particles[r],c=t.posX-h.posX,l=t.posY-h.posY,p=Math.sqrt(c*c+l*l);let d,u=1;if(p<o){d=Math.atan2(h.posY-t.posY,h.posX-t.posX),u=(1/p)**1.8;const i=Math.min(n,u*s),e=Math.cos(d)*i,o=Math.sin(d)*i;t.velX-=e,t.velY-=o,h.velX+=e,h.velY+=o}if(!i)continue;void 0===d&&(d=Math.atan2(h.posY-t.posY,h.posX-t.posX),u=(1/p)**1.8);const f=Math.min(n,u*e),v=Math.cos(d)*f,m=Math.sin(d)*f;t.velX+=v,t.velY+=m,h.velX-=v,h.velY-=m}}}#o(){for(let i of this.particles){i.dir=(i.dir+Math.random()*this.option.particles.rotationSpeed*2-this.option.particles.rotationSpeed)%(2*Math.PI),i.velX*=this.option.gravity.friction,i.velY*=this.option.gravity.friction,i.posX=(i.posX+i.velX+Math.sin(i.dir)*i.speed%this.width+this.width)%this.width,i.posY=(i.posY+i.velY+Math.cos(i.dir)*i.speed%this.height+this.height)%this.height;const s=i.posX+this.offX-this.mouseX,e=i.posY+this.offY-this.mouseY;if(this.option.mouse.interactionType!==t.interactionType.NONE){const t=this.option.mouse.connectDist/Math.hypot(s,e);this.option.mouse.distRatio<t?(i.offX+=(t*s-s-i.offX)/4,i.offY+=(t*e-e-i.offY)/4):(i.offX-=i.offX/4,i.offY-=i.offY/4)}i.x=i.posX+i.offX,i.y=i.posY+i.offY,this.option.mouse.interactionType===t.interactionType.MOVE&&(i.posX=i.x,i.posY=i.y),i.x+=this.offX,i.y+=this.offY,i.gridPos=this.#n(i),i.isVisible=1===i.gridPos.x&&1===i.gridPos.y}}#n(t){return{x:+(t.x>=t.bounds.left)+ +(t.x>t.bounds.right),y:+(t.y>=t.bounds.top)+ +(t.y>t.bounds.bottom)}}#a(t,i){return!(!t.isVisible&&!i.isVisible)||!(t.gridPos.x===i.gridPos.x&&1!==t.gridPos.x||t.gridPos.y===i.gridPos.y&&1!==t.gridPos.y)}#r(){for(let t of this.particles)t.isVisible&&(t.size>1?(this.ctx.beginPath(),this.ctx.arc(t.x,t.y,t.size,0,2*Math.PI),this.ctx.fill(),this.ctx.closePath()):this.ctx.fillRect(t.x-t.size,t.y-t.size,2*t.size,2*t.size))}#h(){const t=this.particleCount,i=this.option.particles.connectDist>=Math.min(this.canvas.width,this.canvas.height),s=this.option.particles.connectDist*this.option.particles.maxWork;for(let e=0;e<t;e++){let o=0;for(let n=e+1;n<t;n++){const t=this.particles[e],a=this.particles[n];if(!i&&!this.#a(t,a))continue;const r=t.x-a.x,h=t.y-a.y,c=Math.sqrt(r*r+h*h);if(!(c>this.option.particles.connectDist)&&(c>this.option.particles.connectDist/2?this.ctx.globalAlpha=this.color.alpha*(this.option.particles.connectDist/c-1):this.ctx.globalAlpha=this.color.alpha,this.ctx.strokeStyle=this.color.hex,this.ctx.beginPath(),this.ctx.moveTo(t.x,t.y),this.ctx.lineTo(a.x,a.y),this.ctx.stroke(),(o+=c)>=s))break}}}#t(){this.canvas.width=this.canvas.width,this.ctx.globalAlpha=this.color.alpha,this.ctx.fillStyle=this.color.hex,this.ctx.lineWidth=1,this.#r(),this.#h()}#c(){this.isAnimating&&(requestAnimationFrame(()=>this.#c()),++this.updateCount>=this.option.framesPerUpdate&&(this.updateCount=0,this.#e(),this.#o(),this.#t()))}start({auto:t=!1}={}){return this.isAnimating||t&&!this.enableAnimating||(this.enableAnimating=!0,this.isAnimating=!0,requestAnimationFrame(()=>this.#c())),!this.canvas.inViewbox&&this.option.animation.startOnEnter&&(this.isAnimating=!1),this}stop({auto:t=!1,clear:i=!0}={}){return t||(this.enableAnimating=!1),this.isAnimating=!1,!1!==i&&(this.canvas.width=this.canvas.width),!0}destroy(){this.stop(),t.canvasIntersectionObserver.unobserve(this.canvas),t.canvasResizeObserver.unobserve(this.canvas),window.removeEventListener("mousemove",this.handleMouseMove),window.removeEventListener("scroll",this.handleScroll),this.canvas?.remove(),Object.keys(this).forEach(t=>delete this[t])}set options(t){const i=(t,i,s)=>{const{min:e=-1/0,max:o=1/0}=s??{};return((t,i)=>isNaN(+t)?i:+t)(Math.min(Math.max(t??i,e),o),i)};this.option={background:t.background??!1,framesPerUpdate:i(t.framesPerUpdate,1,{min:1}),animation:{startOnEnter:!!(t.animation?.startOnEnter??1),stopOnLeave:!!(t.animation?.stopOnLeave??1)},mouse:{interactionType:i(t.mouse?.interactionType,1),connectDistMult:i(t.mouse?.connectDistMult,2/3),connectDist:1,distRatio:i(t.mouse?.distRatio,2/3)},particles:{regenerateOnResize:!!t.particles?.regenerateOnResize,color:t.particles?.color??"black",ppm:i(t.particles?.ppm,100),max:i(t.particles?.max,500),maxWork:i(t.particles?.maxWork,1/0,{min:0}),connectDist:i(t.particles?.connectDistance,150,{min:1}),relSpeed:i(t.particles?.relSpeed,1,{min:0}),relSize:i(t.particles?.relSize,1,{min:1}),rotationSpeed:i(t.particles?.rotationSpeed,2,{min:0})/100},gravity:{repulsive:i(t.gravity?.repulsive,0),pulling:i(t.gravity?.pulling,0),friction:i(t.gravity?.friction,.8,{min:0,max:1})}},this.setBackground(this.option.background),this.setMouseConnectDistMult(this.option.mouse.connectDistMult),this.setParticleColor(this.option.particles.color)}get options(){return this.option}setBackground(t){if(t){if("string"!=typeof t)throw new TypeError("background is not a string");this.canvas.style.background=this.option.background=t}}setMouseConnectDistMult(t){this.option.mouse.connectDist=this.option.particles.connectDist*(isNaN(t)?2/3:t)}setParticleColor(t){if(this.ctx.fillStyle=t,"#"===String(this.ctx.fillStyle)[0])this.color.hex=String(this.ctx.fillStyle),this.color.alpha=1;else{let t=String(this.ctx.fillStyle).split(",").at(-1);t=t?.slice(1,-1)??"1",this.color.alpha=isNaN(+t)?1:+t,this.ctx.fillStyle=String(this.ctx.fillStyle).split(",").slice(0,-1).join(",")+", 1)",this.color.hex=this.ctx.fillStyle}}}return t});
